{"./":{"url":"./","title":"Introduction","keywords":"","body":"程序员的日常工作记录 一个人的工作职位不怕低，只要你不放弃你的理想，拿目前的工作做一个踏脚石，一方面维持生活，一方面找时间充实自己，认准一个确定的方向去努力。慢慢的，你总会发现，你的努力没有白费。 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:41:20 "},"content/spring/transcation.html":{"url":"content/spring/transcation.html","title":"Spring 事务管理","keywords":"","body":"Spring 事务管理 关键类 public interface PlatformTransactionManager { TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException; } 事务真正的开始、提交、回滚都是通过PlatformTransactionManager这个接口来实现的，例如，我们常用的org.springframework.jdbc.datasource.DataSourceTransactionManager。 TransactionDefinition用于获取事务的一些属性，Isolation, Propagation，Timeout，Read-only，还定义了事务隔离级别，传播属性等常量。 TransactionStatus用于设置和查询事务的状态，如是否是新事务，是否有保存点，设置和查询RollbackOnly等。 声明式事务 所谓声明式事务，就是通过配置的方式省去很多代码，从而让Spring来帮你管理事务。本质上就是配置一个Around方式的AOP，在执行方法之前，用TransactionInterceptor截取，然后调用PlatformTransactionManager的某个实现做一些事务开始前的事情，然后在方法执行后，调用PlatformTransactionManager的某个实现做commit或rollback. 如图： 声明式事务可以通过XML配置，也可以通过Annotation的方式来配置，还可以两种结合。平时项目中看到比较多的是两种结合的方式，在XML中配置数据源，事务管理器，然后AOP相关的通过@Transactional(该注解可以注在Class,Method上)来配置。（个人感觉，AOP相关的配置用XML配置挺繁琐的，还是注解好）例如： @Transactional(readOnly = true) public class DefaultFooService{ public Foo getFoo(String fooName) { // do something } @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW) public void updateFoo(Foo foo) { // do something } } 事务属性 引用官方文档的表格 value，在有多个事务管理器存在的情况下，用于标识使用哪个事务管理器 isolation，事务的隔离级别，默认是Isolation.DEFAULT，这个DEFAULT是和具体使用的数据库相关的。关于隔离级别，可以参考MySQL事务学习总结 readOnly, 是否只读，如果配置了true，但是方法里使用了update，insert语句，会报错。对于只读的事务，配置为true有助于提高性能。 rollbackFor, noRollbackFor. Spring的声明式事务的默认行为是如果方法抛出RuntimeException或者Error,则事务会回滚，对于其他的checked类型的异常，不会回滚。如果想改变这种默认行为，可以通过这几个属性来配置。 propagation, 后面会具体讲。 事务的传播机制 类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是 最常见的选择。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行 PROPAGATION_MANDATOR 使用当前的事务，如果当前没有事务，就抛出异常 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作 其他的都还好理解，后面结合例子重点介绍下PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW，PROPAGATION_NESTED三种传播级别。 表结构和原始数据 mysql> select * from test; +----+-------+ | id | money | +----+-------+ | 3 | 500 | | 5 | 500 | | 7 | 600 | +----+-------+ 3 rows in set (0.00 sec) PROPAGATION_REQUIRED @Service public class MysqlTest01 { @Autowired private JdbcTemplate jdbcTemplate; @Autowired private MysqlTest02 mysqlTest02; @Transactional public void test() { jdbcTemplate.execute(\"update test set money = '501' where id = 3\"); try { mysqlTest02.test(); } catch (Exception e) { System.out.println(\"第二个事务异常\"); } } } @Service class MysqlTest02 { @Autowired private JdbcTemplate jdbcTemplate; @Transactional(propagation = Propagation.REQUIRED) public void test() { jdbcTemplate.execute(\"update test set money = '502' where id = 3\"); throw new RuntimeException(); } } 执行完之后，test表的数据没有任何变化。 由于MysqlTest02中的事务传播类型是Propagation.REQUIRED，逻辑上有两个事务，但底层是共用一个物理事务的，第二个事务的抛出RuntimeExcetion导致事务回滚，对于这种传播类型，内层事务的回滚会导致外层事务回滚。所以数据库中的数据没有任何变化。 PROPAGATION_REQUIRES_NEW @Service public class MysqlTest01 { @Autowired private JdbcTemplate jdbcTemplate; @Autowired private MysqlTest02 mysqlTest02; @Transactional public void test() { jdbcTemplate.execute(\"update test set money = '501' where id = 3\"); try { mysqlTest02.test(); } catch (Exception e) { System.out.println(\"第二个事务异常\"); } } } @Service class MysqlTest02 { @Autowired private JdbcTemplate jdbcTemplate; @Transactional(propagation = Propagation.REQUIRES_NEW) public void test() { jdbcTemplate.execute(\"update test set money = '502' where id = 3\"); throw new RuntimeException(); } } 同样的代码，唯一的区别就是第二个事务的传播属性改成了REQUIRES_NEW，执行结果是啥？不好意思，第二个事务执行不了。 对于REQUIRES_NEW，逻辑上有两个事务，底层物理上也有两个事务，由于第一个事务和第二个事务更新的是同一条记录，对于Mysql默认的隔离级别REPEATABLE-READ来说，第一个事务会对该记录加排他锁，所以第二个事务就一直卡住了。 OK，我们把第二个事务的执行的SQL语句换成。 update test set money = '501' where id = 5\" 执行结果如下，可以看到只有第二个事务回滚了。 mysql> select * from test; +----+-------+ | id | money | +----+-------+ | 5 | 500 | | 3 | 501 | | 7 | 600 | +----+-------+ 3 rows in set (0.00 sec) PROPAGATION_NESTED 对于这种传播类型，物理上只有一个事务，不过可以有多个savePoint用来回滚。当然是用这种传播类型，需要数据库支持savePoint，使用jdbc的也是要3.0版本以上(这个不太确定)。 @Service public class MysqlTest01 { @Autowired private JdbcTemplate jdbcTemplate; @Autowired private MysqlTest02 mysqlTest02; @Autowired private MysqlTest03 mysqlTest03; @Transactional public void test() { jdbcTemplate.execute(\"update test set money = '501' where id = 3\"); try { mysqlTest02.test(); } catch (Exception e) { System.out.println(\"第二个事务异常\"); } mysqlTest03.test(); } } @Service class MysqlTest02 { @Autowired private JdbcTemplate jdbcTemplate; @Transactional(propagation = Propagation.NESTED) public void test() { jdbcTemplate.execute(\"update test set money = '502' where id = 3\"); throw new RuntimeException(); } } @Service class MysqlTest03 { @Autowired private JdbcTemplate jdbcTemplate; @Transactional(propagation = Propagation.NESTED) public void test() { jdbcTemplate.execute(\"update test set money = '503' where id = 3\"); } } 执行结果是如下，可以看到第一个事务和第三个事务提交成功了，第二个事务回滚了。物理上它们是在一个事务里的，只不过用到了保存点的技术。 mysql> select * from test; +----+-------+ | id | money | +----+-------+ | 5 | 500 | | 3 | 501 | | 7 | 601 | +----+-------+ 3 rows in set (0.01 sec) 其他 在写测试代码的时候遇到了一个关于AOP的问题，可以看到我的测试代码，每个事务都是在一个新的class中写的。为什么不像下面这样写呢？ @Service public class MysqlTest01 { @Autowired private JdbcTemplate jdbcTemplate; @Transactional public void test01() { jdbcTemplate.execute(\"update test set money = '501' where id = 3\"); test02(); } @Transactional public void test02() { jdbcTemplate.execute(\"update test set money = '501' where id = 5\"); } } 这是因为在Spring的AOP中，test01调用test02, test02是不会被AOP截获的，所以也不会被Spring进行事务管理。原因是Spring AOP的实现本质是通过动态代理的方式去执行真正的方法，然后在代理类里面做一些额外的事情。当通过别的类调用MysqlTest01中的test01方法时，因为使用了Spring的DI，注入的其实是一个MysqlTest01的一个代理类，而通过内部方法调用test02时，则不是。 转载 https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651483890&idx=1&sn=a11cd4b321683b5673d0a08657db8689&chksm=bd25028d8a528b9b80dca38852dba6cace08226339125f5cf55adf9132033fba19080d6ae0da&mpshare=1&scene=1&srcid=#rd Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-10 16:40:42 "},"content/java/java1.html":{"url":"content/java/java1.html","title":"JVM原理讲解","keywords":"","body":"JVM原理讲解 本文从 JVM 结构入手，介绍了 Java 内存管理、对象创建、常量池等基础知识，对面试中 JVM 相关的基础题目进行了讲解。 基本问题 介绍下Java内存区域（运行时数据区） Java对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么） 对象的访问定位的两种方式（句柄和直接指针两种方式） 拓展问题 String类和常量池 8种基本类型的包装类和常量池 概述 对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要像C++程序员这样为每一个new操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题，正是因为Java程序员把内存控制权交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。 运行时数据区 Java虚拟机在执行Java程序的过程中会把它管理的内存分成若干个不同的数据区域。 线程私有的：程序计数器，虚拟机栈，本地方法栈 线程共享的：堆，方法区，直接内存 程序计数器 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器来选择去下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 从上面的介绍中我们知道程序计数器主要有两个作用: 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行，选择，循环，异常处理 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了 注意：程序计数器是唯一不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 Java虚拟机栈 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型。 Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有局部变量表，操作数栈，动态链接，方法出口信息） 局部变量表主要存放可编译器可知的各种数据类型(boolean, byte, char, short, int, float, long, double)，对象引用（refrence类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 Java虚拟机栈会出现两种异常: StackOverFlowError 和 OutOfMemoryError。 StackOverFlowEror：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 OutOfMemoryError: 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。 Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 本地方法栈 和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈会创建一个栈桢，用于存放该本地方法的局部变量表，操作数栈，动态链接，出口信息。 方法执行完毕后相应的栈桢也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种异常。 堆 Java虚拟机所管理的内存中最大的一块，Java堆使所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例以及数组都在这里分配内存。 Java堆是垃圾收集管理器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap)。从垃圾回收的角度，由于现在收集器基本采用的分代垃圾收集算法，所以Java堆还可以细分为: 新生代和老年代，再细致一点: Eden空间，From Survivor, To Survivor空间等。进一步划分的目的是更好的回收内存，或者更快的分配内存。 在JDK1.8中移除了整个永久代，取而代之的是一个叫元空间(Metaspace)的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。 【参考】Java8内存模型--永久代(PermGen)和元空间(Metaspace) 方法区 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java堆区分开来。 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:40:45 "},"content/java/java2.html":{"url":"content/java/java2.html","title":"java同步系列之JMM","keywords":"","body":"java同步系列之JMM（Java Memory Model） Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。 简介 Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。 硬件内存模型 在正式讲解Java的内存模型之前，我们有必要先了解一下硬件层面的一些东西。 在现代计算机的硬件体系中，CPU的运算速度是非常快的，远远高于它从存储介质读取数据的速度，这里的存储介质有很多，比如磁盘、光盘、网卡、内存等，这些存储介质有一个很明显的特点——距离CPU越近的存储介质往往越小越贵越快，距离CPU越远的存储介质往往越大越便宜越慢。 所以，在程序运行的过程中，CPU大部分时间都浪费在了磁盘IO、网络通讯、数据库访问上，如果不想让CPU在那里白白等待，我们就必须想办法去把CPU的运算能力压榨出来，否则就会造成很大的浪费，而让CPU同时去处理多项任务则是最容易想到的，也是被证明非常有效的压榨手段，这也就是我们常说的“并发执行”。 但是，让CPU并发地执行多项任务并不是那么容易实现的事，因为所有的运算都不可能只依靠CPU的计算就能完成，往往还需要跟内存进行交互，如读取运算数据、存储运算结果等。 前面我们也说过了，CPU与内存的交互往往是很慢的，所以这就要求我们要想办法在CPU和内存之间建立一种连接，使它们达到一种平衡，让运算能快速地进行，而这种连接就是我们常说的“高速缓存”。 高速缓存的速度是非常接近CPU的，但是它的引入又带来了新的问题，现代的CPU往往是有多个核心的，每个核心都有自己的缓存，而多个核心之间是不存在时间片的竞争的，它们可以并行地执行，那么，怎么保证这些缓存与主内存中的数据的一致性就成为了一个难题。 为了解决缓存一致性的问题，多个核心在访问缓存时要遵循一些协议，在读写操作时根据协议来操作，这些协议有MSI、MESI、MOSI等，它们定义了何时应该访问缓存中的数据、何时应该让缓存失效、何时应该访问主内存中的数据等基本原则。 而随着CPU能力的不断提升，一层缓存就无法满足要求了，就逐渐衍生出了多级缓存。 按照数据读取顺序和CPU的紧密程度，CPU的缓存可以分为一级缓存（L1）、二级缓存（L2）、三级缓存（L3），每一级缓存存储的数据都是下一级的一部分。 这三种缓存的技术难度和制作成本是相对递减的，容量也是相对递增的。 所以，在有了多级缓存后，程序的运行就变成了： 当CPU要读取一个数据的时候，先从一级缓存中查找，如果没找到再从二级缓存中查找，如果没找到再从三级缓存中查找，如果没找到再从主内存中查找，然后再把找到的数据依次加载到多级缓存中，下次再使用相关的数据直接从缓存中查找即可。 而加载到缓存中的数据也不是说用到哪个就加载哪个，而是加载内存中连续的数据，一般来说是加载连续的64个字节，因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中，这就是“缓存行”的概念。 缓存行虽然能极大地提高程序运行的效率，但是在多线程对共享变量的访问过程中又带来了新的问题，也就是非常著名的“伪共享”。 关于伪共享的问题，我们这里就不展开讲了，有兴趣的可以看彤哥之前发布的【杂谈 什么是伪共享（false sharing）？】章节的相关内容。 除此之外，为了使CPU中的运算单元能够充分地被利用，CPU可能会对输入的代码进行乱序执行优化，然后在计算之后再将乱序执行的结果进行重组，保证该结果与顺序执行的结果一致，但并不保证程序中各个语句计算的先后顺序与代码的输入顺序一致，因此，如果一个计算任务依赖于另一个计算任务的结果，那么其顺序性并不能靠代码的先后顺序来保证。 与CPU的乱序执行优化类似，java虚拟机的即时编译器也有类似的指令重排序优化。 为了解决上面提到的多个缓存读写一致性以及乱序排序优化的问题，这就有了内存模型，它定义了共享内存系统中多线程读写操作行为的规范。 Java内存模型 Java内存模型（Java Memory Model，JMM）是在硬件内存模型基础上更高层的抽象，它屏蔽了各种硬件和操作系统对内存访问的差异性，从而实现让Java程序在各种平台下都能达到一致的并发效果。 Java内存模型定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里所说的变量包括实例字段、静态字段，但不包括局部变量和方法参数，因为它们是线程私有的，它们不会被共享，自然不存在竞争问题。 为了获得更好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码的执行顺序等这类权利。 Java内存模型规定了所有的变量都存储在主内存中，这里的主内存跟介绍硬件时所用的名字一样，两者可以类比，但此处仅指虚拟机中内存的一部分。 除了主内存，每条线程还有自己的工作内存，此处可与CPU的高速缓存进行类比。工作内存中保存着该线程使用到的变量的主内存副本的拷贝，线程对变量的操作都必须在工作内存中进行，包括读取和赋值等，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。 线程、工作内存、主内存三者的关系如下图所示： 注意，这里所说的主内存、工作内存跟Java虚拟机内存区域划分中的堆、栈是不同层次的内存划分，如果两者一定要勉强对应起来，主内存主要对应于堆中对象的实例部分，而工作内存主要对应与虚拟机栈中的部分区域。 从更低层次来说，主内存主要对应于硬件内存部分，工作内存主要对应于CPU的高速缓存和寄存器部分，但也不是绝对的，主内存也可能存在于高速缓存和寄存器中，工作内存也可能存在于硬件内存中。 内存间的交互操作 关于主内存与工作内存之间具体的交互协议，Java内存模型定义了以下8种具体的操作来完成： （1）lock，锁定，作用于主内存的变量，它把主内存中的变量标识为一条线程独占状态； （2）unlock，解锁，作用于主内存的变量，它把锁定的变量释放出来，释放出来的变量才可以被其它线程锁定； （3）read，读取，作用于主内存的变量，它把一个变量从主内存传输到工作内存中，以便后续的load操作使用； （4）load，载入，作用于工作内存的变量，它把read操作从主内存得到的变量放入工作内存的变量副本中； （5）use，使用，作用于工作内存的变量，它把工作内存中的一个变量传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作； （6）assign，赋值，作用于工作内存的变量，它把一个从执行引擎接收到的变量赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时使用这个操作； （7）store，存储，作用于工作内存的变量，它把工作内存中一个变量的值传递到主内存中，以便后续的write操作使用； （8）write，写入，作用于主内存的变量，它把store操作从工作内存得到的变量的值放入到主内存的变量中； 如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，同样地，如果要把一个变量从工作内存同步回主内存，就要按顺序地执行store和write操作。注意，这里只说明了要按顺序，并没有说一定要连续，也就是说可以在read与load之间、store与write之间插入其它操作。比如，对主内存中的变量a和b的访问，可以按照以下顺序执行： read a -> read b -> load b -> load a。 另外，Java内存模型还定义了执行上述8种操作的基本规则： （1）不允许read和load、store和write操作之一单独出现，即不允许出现从主内存读取了而工作内存不接受，或者从工作内存回写了但主内存不接受的情况出现； （2）不允许一个线程丢弃它最近的assign操作，即变量在工作内存变化了必须把该变化同步回主内存； （3）不允许一个线程无原因地（即未发生过assign操作）把一个变量从工作内存同步回主内存； （4）一个新的变量必须在主内存中诞生，不允许工作内存中直接使用一个未被初始化（load或assign）过的变量，换句话说就是对一个变量的use和store操作之前必须执行过load和assign操作； （5）一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能被解锁。 （6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值； （7）如果一个变量没有被lock操作锁定，则不允许对其执行unlock操作，也不允许unlock一个其它线程锁定的变量； （8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作； 注意，这里的lock和unlock是实现synchronized的基础，Java并没有把lock和unlock操作直接开放给用户使用，但是却提供了两个更高层次的指令来隐式地使用这两个操作，即moniterenter和moniterexit。 原子性、可见性、有序性 Java内存模型就是为了解决多线程环境下共享变量的一致性问题，那么一致性包含哪些内容呢？ 一致性主要包含三大特性：原子性、可见性、有序性，下面我们就来看看Java内存模型是怎么实现这三大特性的。 （1）原子性 原子性是指一段操作一旦开始就会一直运行到底，中间不会被其它线程打断，这段操作可以是一个操作，也可以是多个操作。 由Java内存模型来直接保证的原子性操作包括read、load、user、assign、store、write这两个操作，我们可以大致认为基本类型变量的读写是具备原子性的。 如果应用需要一个更大范围的原子性，Java内存模型还提供了lock和unlock这两个操作来满足这种需求，尽管不能直接使用这两个操作，但我们可以使用它们更具体的实现synchronized来实现。 因此，synchronized块之间的操作也是原子性的。 （2）可见性 可见性是指当一个线程修改了共享变量的值，其它线程能立即感知到这种变化。 Java内存模型是通过在变更修改后同步回主内存，在变量读取前从主内存刷新变量值来实现的，它是依赖主内存的，无论是普通变量还是volatile变量都是如此。 普通变量与volatile变量的主要区别是是否会在修改之后立即同步回主内存，以及是否在每次读取前立即从主内存刷新。因此我们可以说volatile变量保证了多线程环境下变量的可见性，但普通变量不能保证这一点。 除了volatile之外，还有两个关键字也可以保证可见性，它们是synchronized和final。 synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作”这条规则获取的。 final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，那么其它线程中就能看见这个final字段了。 （3）有序性 Java程序中天然的有序性可以总结为一句话：如果在本线程中观察，所有的操作都是有序的；如果在另一个线程中观察，所有的操作都是无序的。 前半句是指线程内表现为串行的语义，后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。 Java中提供了volatile和synchronized两个关键字来保证有序性。 volatile天然就具有有序性，因为其禁止重排序。 synchronized的有序性是由“一个变量同一时刻只允许一条线程对其进行lock操作”这条规则获取的。 先行发生原则（Happens-Before） 如果Java内存模型的有序性都只依靠volatile和synchronized来完成，那么有一些操作就会变得很啰嗦，但是我们在编写Java并发代码时并没有感受到，这是因为Java语言天然定义了一个“先行发生”原则，这个原则非常重要，依靠这个原则我们可以很容易地判断在并发环境下两个操作是否可能存在竞争冲突问题。 先行发生，是指操作A先行发生于操作B，那么操作A产生的影响能够被操作B感知到，这种影响包括修改了共享内存中变量的值、发送了消息、调用了方法等。 下面我们看看Java内存模型定义的先行发生原则有哪些： （1）程序次序原则 在一个线程内，按照程序书写的顺序执行，书写在前面的操作先行发生于书写在后面的操作，准确地讲是控制流顺序而不是代码顺序，因为要考虑分支、循环等情况。 （2）监视器锁定原则 一个unlock操作先行发生于后面对同一个锁的lock操作。 （3）volatile原则 对一个volatile变量的写操作先行发生于后面对该变量的读操作。 （4）线程启动原则 对线程的start()操作先行发生于线程内的任何操作。 （5）线程终止原则 线程中的所有操作先行发生于检测到线程终止，可以通过Thread.join()、Thread.isAlive()的返回值检测线程是否已经终止。 （6）线程中断原则 对线程的interrupt()的调用先行发生于线程的代码中检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否发生中断。 （7）对象终结原则 一个对象的初始化完成（构造方法执行结束）先行发生于它的finalize()方法的开始。 （8）传递性原则 如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。 这里说的“先行发生”与“时间上的先发生”没有必然的关系。 比如，下面的代码： int a = 0; // 操作A：线程1对进行赋值操作 a = 1; // 操作B：线程2获取a的值 int b = a; 复制代码 如果线程1在时间顺序上先对a进行赋值，然后线程2再获取a的值，这能说明操作A先行发生于操作B吗？ 显然不能，因为线程2可能读取的还是其工作内存中的值，或者说线程1并没有把a的值刷新回主内存呢，这时候线程2读取到的值可能还是0。 所以，“时间上的先发生”不一定“先行发生”。 再看一个例子： // 同一个线程中 int i = 1; int j = 2; 复制代码 根据第一条程序次序原则，int i = 1;先行发生于int j = 2;，但是由于处理器优化，可能导致int j = 2;先执行，但是这并不影响先行发生原则的正确性，因为我们在这个线程中并不会感知到这点。 所以，“先行发生”不一定“时间上先发生”。 总结 （1）硬件内存架构使得我们必须建立内存模型来保证多线程环境下对共享内存访问的正确性； （2）Java内存模型定义了保证多线程环境下共享变量一致性的规则； （3）Java内存模型提供了工作内存与主内存交互的8大操作：lock、unlock、read、load、use、assign、store、write； （4）Java内存模型对原子性、可见性、有序性提供了一些实现； （5）先行发生的8大原则：程序次序原则、监视器锁定原则、volatile原则、线程启动原则、线程终止原则、线程中断原则、对象终结原则、传递性原则； （6）先行发生不等于时间上的先发生； Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 21:09:34 "},"content/linux/linux_1.html":{"url":"content/linux/linux_1.html","title":"几个Linux常用命令","keywords":"","body":"Linux几个基本命令 系统监控工具 1.vmstat - 虚拟内存统计 vmstat 命令报告有关进程、内存、分页、块 IO、中断和 CPU 活动等信息。 # vmstat 3 输出示例： procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 2540988 522188 5130400 0 0 2 32 4 2 4 1 96 0 0 1 0 0 2540988 522188 5130400 0 0 0 720 1199 665 1 0 99 0 0 0 0 0 2540956 522188 5130400 0 0 0 0 1151 1569 4 1 95 0 0 0 0 0 2540956 522188 5130500 0 0 0 6 1117 439 1 0 99 0 0 0 0 0 2540940 522188 5130512 0 0 0 536 1189 932 1 0 98 0 0 0 0 0 2538444 522188 5130588 0 0 0 0 1187 1417 4 1 96 0 0 0 0 0 2490060 522188 5130640 0 0 0 18 1253 1123 5 1 94 0 0 2.找出占用内存资源最多的前 10 个进程 ps -auxf | sort -nr -k 4 | head -10 3.找出占用 CPU 资源最多的前 10 个进程 ps -auxf | sort -nr -k 3 | head -10 JPS-Java进程状态工具 列出PID和Java主类名 jps 2017 Bootstrap 2576 Jps 列出pid和java完整主类名 jps -l 2017 org.apache.catalina.startup.Bootstrap 2612 sun.tools.jps.Jps 列出pid、主类全称和应用程序参数 jps -lm 2017 org.apache.catalina.startup.Bootstrap start 2588 sun.tools.jps.Jps -lm 列出pid和JVM参数 jps -v 2017 Bootstrap -Djava.util.logging.config.file=/usr/local/tomcat-web/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Dfile.encoding=UTF-8 -Xms256m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512m -verbose:gc -Xloggc:/usr/local/tomcat-web/logs/gc.log-2014-02-07 -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xnoclassgc -Djava.endorsed.dirs=/usr/local/tomcat-web/endorsed -Dcatalina.base=/usr/local/tomcat-web -Dcatalina.home=/usr/local/tomcat-web -Djava.io.tmpdir=/usr/local/tomcat-web/temp 2624 Jps -Dapplication.home=/usr/lib/jvm/jdk1.6.0_43 -Xms8m 和【ps -ef | grep java】类似的输出 jps -lvm 2017 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file=/usr/local/tomcat-web/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Dfile.encoding=UTF-8 -Xms256m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512m -verbose:gc -Xloggc:/usr/local/tomcat-web/logs/gc.log-2014-02-07 -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xnoclassgc -Djava.endorsed.dirs=/usr/local/tomcat-web/endorsed -Dcatalina.base=/usr/local/tomcat-web -Dcatalina.home=/usr/local/tomcat-web -Djava.io.tmpdir=/usr/local/tomcat-web/temp 2645 sun.tools.jps.Jps -lvm -Dapplication.home=/usr/lib/jvm/jdk1.6.0_43 -Xms8m AB压力测试工具 安装 yum -y install httpd-tools 检测 ab -V This is ApacheBench, Version 2.3 Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ ab参数说明 有关ab命令的使用，我们可以通过帮助命令进行查看。如下： ab --help 下面我们对这些参数，进行相关说明。如下： -n在测试会话中所执行的请求个数。默认时，仅执行一个请求。 -c一次产生的请求个数。默认是一次一个。 -t测试所进行的最大秒数。其内部隐含值是-n 50000，它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -p包含了需要POST的数据的文件。 -P对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。 -T POST数据所使用的Content-type头信息。 -v设置显示信息的详细程度-4或更大值会显示头信息，3或更大值可以显示响应代码(404,200等),2或更大值可以显示警告和其他信息。 -V显示版本号并退出。 -w以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。 -i执行HEAD请求，而不是GET。 -x设置属性的字符串。 -X对请求使用代理服务器。 -y设置属性的字符串。 -C对请求附加一个Cookie:行。其典型形式是name=value的一个参数对，此参数可以重复。 -H对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含了以冒号分隔的字段和值的对(如,\"Accept-Encoding:zip/zop;8bit\")。 -A对服务器提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即,是否发送了401认证需求代码)，此字符串都会被发送。 -h显示使用方法。 -d不显示\"percentage served within XX [ms] table\"的消息(为以前的版本提供支持)。 -e产生一个以逗号分隔的(CSV)文件，其中包含了处理每个相应百分比的请求所需要(从1%到100%)的相应百分比的(以微妙为单位)时间。由于这种格式已经“二进制化”，所以比'gnuplot'格式更有用。 -g把所有测试结果写入一个'gnuplot'或者TSV(以Tab分隔的)文件。此文件可以方便地导入到Gnuplot,IDL,Mathematica,Igor甚至Excel中。其中的第一行为标题。 -i执行HEAD请求，而不是GET。 -k启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。默认时，不启用KeepAlive功能。 -q如果处理的请求数大于150，ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。此-q标记可以抑制这些信息。 ab性能指标 在进行性能测试过程中有几个指标比较重要： 1、吞吐率（Requests per second） 服务器并发处理能力的量化描述，单位是reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。 记住：吞吐率是基于并发用户数的。这句话代表了两个含义： a、吞吐率和并发用户数相关 b、不同的并发用户数下，吞吐率一般是不同的 计算公式：总请求数/处理完成这些请求数所花费的时间，即 Request per second=Complete requests/Time taken for tests 必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。 2、并发连接数（The number of concurrent connections） 并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。 3、并发用户数（Concurrency Level） 要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在HTTP/1.1下，IE7支持两个并发连接，IE8支持6个并发连接，FireFox3支持4个并发连接，所以相应的，我们的并发用户数就得除以这个基数。 4、用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间/（总请求数/并发用户数），即： Time per request=Time taken for tests/（Complete requests/Concurrency Level） 5、服务器平均请求等待时间（Time per request:across all concurrent requests） 计算公式：处理完成所有请求数所花费的时间/总请求数，即： Time taken for/testsComplete requests 可以看到，它是吞吐率的倒数。 同时，它也等于用户平均请求等待时间/并发用户数，即 Time per request/Concurrency Level ab实际使用 ab的命令参数比较多，我们经常使用的是-c和-n参数。 ab -c 10 -n 100 http://www.xxx.com/index.php -c10表示并发用户数为10 -n100表示请求总数为100 http://www.xxx.com/index.php表示请求的目标URL 这行表示同时处理100个请求并运行10次index.php文件。 TOP命令查看CPU利用率 linux下用top命令查看cpu利用率超过100%，这里显示的所有的cpu加起来的使用率，说明你的CPU是多核，你运行top后按大键盘1看看，可以显示每个cpu的使用率，top里显示的是把所有使用率加起来。 按下1后可以看到我的机器的CPU是双核的。%Cpu0，%Cpu1，%Cpu2...... 这里我们也可以查看一下CPU信息：在命令行里输入：cat /proc/cpuinfo 这里可以看到cpu cores : 11 find用法 Linux中find常见用法示例 ·find path -option [ -print ] [ -exec -ok command ] {} \\; find命令的参数； pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \\;，注意{ }和\\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 -print 将查找到的文件输出到标准输出 -exec command {} \\; —–将查到的文件执行command操作,{} 和 \\;之间有空格 -ok 和-exec相同，只不过在操作前要询用户 原文：https://www.cnblogs.com/archoncap/p/6144369.html linux修改默认SSH端口 linux SSH默认端口是22，不修改的话存在一定的风险，要么是被人恶意扫描，要么会被人破解或者攻击，所以我们需要修改默认的SSH端口。 vi /etc/ssh/sshd_config 默认端口是22，并且已经被注释掉了，打开注释修改为其他未占用端口即可。 开启防火墙端口并重复服务即可。 systemctl restart sshd.service 查看某个文件夹的总容量 du -sh 通过ps及top命令查看进程信息 通过ps及top命令查看进程信息时，只能查到相对路径，查不到的进程的详细信息，如绝对路径等。这时，我们需要通过以下的方法来查看进程的详细信息： /proc Linux在启动一个进程时，系统会在/proc下创建一个以PID命名的文件夹，在该文件夹下会有我们的进程的信息， 其中包括一个名为exe的文件即记录了绝对路径，通过ll或ls –l命令即可查看。 ll /proc/PID 比如，我们查看mongo使用以下命令： [root@rmpapp local]# ps -ef|grep mongo root 9466 6380 0 13:41 pts/1 00:00:00 grep --color=auto mongo root 16053 1 0 8月14 ? 06:45:52 ./mongod --config mongodb.conf 然后： ll /proc/16053 Linux远程拷贝同步命令 通常情况下我们需要在两个Linux服务器之间拷贝文件，比如定时备份。 以博客为例，网站目录定时打包比如一周或者一个月，远程同步到备份服务器。 博客服务器输入一下命令，然后输入远程主机密码，即可进行同步拷贝： scp -r /mnt/domains/blog.52itstyle.com_20181024.tar.gz root@115.29.143.135:/home/backups/ 如果想增量拷贝，我们可以使用rsync命令。 rsync -avz /mnt/domains/blog.52itstyle.com root@115.29.143.135:/home/backups/ 如果出现： RSA host key for [ip address] has changed and you have requested strict checking 可能是系统重装后，本地机和服务器内部ssh对不上导致错误，因此，只需要删除本地机ssh缓存信息，即可恢复。 在本地机输入一下命令行： ssh-keygen -R IP Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-11 10:06:54 "},"content/linux/nginx_1.html":{"url":"content/linux/nginx_1.html","title":"Nginx参数配置说明","keywords":"","body":"Nginx参数配置说明 #运行用户 user nobody; #启动进程,通常设置成和cpu的数量相等 worker_processes 1; #全局错误日志及PID文件 #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; #工作模式及连接数上限 events { #epoll是多路复用IO(I/O Multiplexing)中的一种方式, #仅用于linux2.6以上内核,可以大大提高nginx的性能 use epoll; #单个后台worker process进程的最大并发链接数 worker_connections 1024; # 并发总数是 worker_processes 和 worker_connections 的乘积 # 即 max_clients = worker_processes * worker_connections # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4 为什么 # 为什么上面反向代理要除以4，应该说是一个经验值 # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000 # worker_connections 值的设置跟物理内存大小有关 # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数 # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右 # 我们来看看360M内存的VPS可以打开的文件句柄数是多少： # $ cat /proc/sys/fs/file-max # 输出 34336 # 32000 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-11 09:59:25 "},"content/linux/nginx_2.html":{"url":"content/linux/nginx_2.html","title":"Nginx进阶配置","keywords":"","body":"Nginx进阶配置 静态文件服务器 在Java开发过程以及生产环境中，最常用的web应用服务器当属Tomcat，尽管这只猫也能够处理一些静态请求，例如图片、html、样式文件等，但是效率并不是那么尽人意。所以在生产环境中，我们一般使用Nginx代理服务器来处理静态文件，来提升网站性能。 server { listen 80; server_name file.52itstyle.com; charset utf-8; #root 指令用来指定文件在服务器上的基路径 root /data/statics; #location指令用来映射请求到本地文件系统 location / { autoindex on; # 索引 autoindex_exact_size on; # 显示文件大小 autoindex_localtime on; # 显示文件时间 } } 负载均衡 Nginx 提供轮询（round robin）、IP 哈希（client IP）和加权轮询 3 种方式，默认情况下，Nginx 采用的是轮询。 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 upstream backserver { server 192.168.1.14; server 192.168.1.15; } 加权轮询 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 upstream backserver { server 192.168.1.14 weight=1; server 192.168.1.15 weight=2; } ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 upstream backserver { ip_hash; server 192.168.0.14; server 192.168.0.15; } 重试策略 可以为每个 backserver 指定最大的重试次数，和重试时间间隔,所使用的关键字是 max_fails 和 fail_timeout。 upstream backserver { server 192.168.1.14 weight=1 max_fails=2 fail_timeout=30s; server 192.168.1.15 weight=2 max_fails=2 fail_timeout=30s; } 失败重试次数为3，且超时时间为30秒。 热机策略 upstream backserver { server 192.168.1.14 weight=1 max_fails=2 fail_timeout=30s; server 192.168.1.15 weight=2 max_fails=2 fail_timeout=30s; server 192.168.1.16 backup; } 当所有的非备机（non-backup）都宕机（down）或者繁忙（busy）的时候，就会使用由 backup 标注的备机。必须要注意的是，backup 不能和 ip_hash 关键字一起使用。 WebSocket配置实例 Nginx学习之反向代理WebSocket配置实例 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-11 10:00:05 "},"content/linux/tomcat.html":{"url":"content/linux/tomcat.html","title":"Tomcat最佳实践","keywords":"","body":"Tomcat最佳实践 运行模式 Tomcat Connector三种运行模式（BIO, NIO, APR）的比较和优化。 org.apache.coyote.http11.Http11Protocol：BIO org.apache.coyote.http11.Http11NioProtocol：NIO org.apache.coyote.http11.Http11Nio2Protocol：NIO2 org.apache.coyote.http11.Http11AprProtocol：APR BIO 一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。 NIO 利用Java的异步IO处理，可以通过少量的线程处理大量的请求。Tomcat8在Linux系统中默认使用这种方式。Tomcat7必须修改Connector配置来启动： Tomcat8以后NIO2模式： APR 即Apache Portable Runtime，从操作系统层面解决io阻塞问题。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。Linux如果安装了apr和native，Tomcat直接启动就支持apr。 连接池 默认值： 修改为： 参数解释： maxThreads，最大并发数，默认设置 200，一般建议在 500 ~ 800，根据硬件设施和业务来判断 minSpareThreads，Tomcat 初始化时创建的线程数，默认设置 25 prestartminSpareThreads，在 Tomcat 初始化的时候就初始化 minSpareThreads 的参数值，如果不等于 true，minSpareThreads 的值就没啥效果了 maxQueueSize，最大的等待队列数，超过则拒绝请求 默认的链接参数配置： 修改为： 参数解释： protocol，Tomcat 8 设置 nio2 更好：org.apache.coyote.http11.Http11Nio2Protocol protocol，Tomcat 6、7 设置 nio 更好：org.apache.coyote.http11.Http11NioProtocol enableLookups，禁用DNS查询 acceptCount，指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认设置 100 maxPostSize，以 FORM URL 参数方式的 POST 提交方式，限制提交最大的大小，默认是 2097152(2兆)，它使用的单位是字节。10485760 为 10M。如果要禁用限制，则可以设置为 -1 acceptorThreadCount，用于接收连接的线程的数量，默认值是1。一般这个指需要改动的时候是因为该服务器是一个多核CPU，如果是多核 CPU 一般配置为 2 端口配置 Tomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口。 JVM 优化 Java 的内存模型分为： Young，年轻代（易被 GC）。Young 区被划分为三部分，Eden 区和两个大小严格相同的 Survivor 区，其中 Survivor 区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在 Young 区间变满的时候，minor GC 就会将存活的对象移到空闲的Survivor 区间中，根据 JVM 的策略，在经过几次垃圾收集后，任然存活于 Survivor 的对象将被移动到 Tenured 区间。 Tenured，终身代。Tenured 区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在 Young 复制转移一定的次数以后，对象就会被转移到 Tenured 区，一般如果系统中用了 application 级别的缓存，缓存中的对象往往会被转移到这一区间。 Perm，永久代。主要保存 class,method,filed 对象，这部门的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到 java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的 class 没有被卸载掉，这样就造成了大量的 class 对象保存在了 perm 中，这种情况下，一般重新启动应用服务器可以解决问题。 Linux 修改 /tomcat/bin/catalina.sh 文件，把下面信息添加到文件第一行。 机子内存如果是 8G，一般 PermSize 配置是主要保证系统能稳定起来就行： JAVA_OPTS=\"-Dfile.encoding=UTF-8 -server -Xms6144m -Xmx6144m -XX:NewSize=1024m -XX:MaxNewSize=2048m -XX:PermSize=512m -XX:MaxPermSize=512m -XX:MaxTenuringThreshold=10 -XX:NewRatio=2 -XX:+DisableExplicitGC\" 参数说明： -Dfile.encoding：默认文件编码 -server：表示这是应用于服务器的配置，JVM 内部会有特殊处理的 -Xmx1024m：设置JVM最大可用内存为1024MB -Xms1024m：设置JVM最小内存为1024m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -XX:NewSize：设置年轻代大小 -XX:MaxNewSize：设置最大的年轻代大小 -XX:PermSize：设置永久代大小 -XX:MaxPermSize：设置最大永久代大小 -XX:NewRatio=4：设置年轻代（包括 Eden 和两个 Survivor 区）与终身代的比值（除去永久代）。设置为 4，则年轻代与终身代所占比值为 1：4，年轻代占整个堆栈的 1/5 -XX:MaxTenuringThreshold=10：设置垃圾最大年龄，默认为：15。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 -XX:+DisableExplicitGC：这个将会忽略手动调用 GC 的代码使得 System.gc() 的调用就会变成一个空调用，完全不会触发任何 GC Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-11 10:02:07 "},"content/codePart/part1.html":{"url":"content/codePart/part1.html","title":"反射工具类","keywords":"","body":"反射工具类 package com.github.wxiaoqi.security.common.util; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import org.apache.commons.lang3.StringUtils; import org.apache.commons.lang3.Validate; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.Assert; /** * 反射工具类. * 提供调用getter/setter方法, 访问私有变量, 调用私有方法, 获取泛型类型Class, 被AOP过的真实类等工具函数. * @author calvin * @version 2013-01-15 */ @SuppressWarnings(\"rawtypes\") public class ReflectionUtils { private static final String SETTER_PREFIX = \"set\"; private static final String GETTER_PREFIX = \"get\"; private static final String CGLIB_CLASS_SEPARATOR = \"$$\"; private static Logger logger = LoggerFactory.getLogger(ReflectionUtils.class); /** * 调用Getter方法. * 支持多级，如：对象名.对象名.方法 */ public static Object invokeGetter(Object obj, String propertyName) { Object object = obj; for (String name : StringUtils.split(propertyName, \".\")){ String getterMethodName = GETTER_PREFIX + StringUtils.capitalize(name); object = invokeMethod(object, getterMethodName, new Class[] {}, new Object[] {}); } return object; } /** * 调用Setter方法, 仅匹配方法名。 * 支持多级，如：对象名.对象名.方法 */ public static void invokeSetter(Object obj, String propertyName, Object value) { Object object = obj; String[] names = StringUtils.split(propertyName, \".\"); for (int i=0; i type) { if (object instanceof Number) { Number number = (Number) object; if (type.equals(byte.class) || type.equals(Byte.class)) { return number.byteValue(); } if (type.equals(short.class) || type.equals(Short.class)) { return number.shortValue(); } if (type.equals(int.class) || type.equals(Integer.class)) { return number.intValue(); } if (type.equals(long.class) || type.equals(Long.class)) { return number.longValue(); } if (type.equals(float.class) || type.equals(Float.class)) { return number.floatValue(); } if (type.equals(double.class) || type.equals(Double.class)) { return number.doubleValue(); } } if(type.equals(String.class)){ return object==null?\"\":object.toString(); } return object; } /** * 直接调用对象方法, 无视private/protected修饰符. * 用于一次性调用的情况，否则应使用getAccessibleMethod()函数获得Method后反复调用. * 同时匹配方法名+参数类型， */ public static Object invokeMethod(final Object obj, final String methodName, final Class[] parameterTypes, final Object[] args) { Method method = getAccessibleMethod(obj, methodName, parameterTypes); if (method == null) { throw new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + obj + \"]\"); } try { return method.invoke(obj, args); } catch (Exception e) { throw convertReflectionExceptionToUnchecked(e); } } /** * 直接调用对象方法, 无视private/protected修饰符， * 用于一次性调用的情况，否则应使用getAccessibleMethodByName()函数获得Method后反复调用. * 只匹配函数名，如果有多个同名函数调用第一个。 */ public static Object invokeMethodByName(final Object obj, final String methodName, final Object[] args) { Method method = getAccessibleMethodByName(obj, methodName); if (method == null) { throw new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + obj + \"]\"); } try { return method.invoke(obj, args); } catch (Exception e) { throw convertReflectionExceptionToUnchecked(e); } } /** * 循环向上转型, 获取对象的DeclaredField, 并强制设置为可访问. * * 如向上转型到Object仍无法找到, 返回null. */ public static Field getAccessibleField(final Object obj, final String fieldName) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(fieldName, \"fieldName can't be blank\"); for (Class superClass = obj.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()) { try { Field field = superClass.getDeclaredField(fieldName); makeAccessible(field); return field; } catch (NoSuchFieldException e) {//NOSONAR // Field不在当前类定义,继续向上转型 continue;// new add } } return null; } /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 匹配函数名+参数类型。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) */ public static Method getAccessibleMethod(final Object obj, final String methodName, final Class... parameterTypes) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(methodName, \"methodName can't be blank\"); for (Class searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) { try { Method method = searchType.getDeclaredMethod(methodName, parameterTypes); makeAccessible(method); return method; } catch (NoSuchMethodException e) { // Method不在当前类定义,继续向上转型 continue;// new add } } return null; } /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 只匹配函数名。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) */ public static Method getAccessibleMethodByName(final Object obj, final String methodName) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(methodName, \"methodName can't be blank\"); for (Class searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) { Method[] methods = searchType.getDeclaredMethods(); for (Method method : methods) { if (method.getName().equals(methodName)) { makeAccessible(method); return method; } } } return null; } /** * 改变private/protected的方法为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 */ public static void makeAccessible(Method method) { if ((!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) { method.setAccessible(true); } } /** * 改变private/protected的成员变量为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 */ public static void makeAccessible(Field field) { if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier .isFinal(field.getModifiers())) && !field.isAccessible()) { field.setAccessible(true); } } /** * 通过反射, 获得Class定义中声明的泛型参数的类型, 注意泛型必须定义在父类处 * 如无法找到, 返回Object.class. * eg. * public UserDao extends HibernateDao * * @param clazz The class to introspect * @return the first generic declaration, or Object.class if cannot be determined */ @SuppressWarnings(\"unchecked\") public static Class getClassGenricType(final Class clazz) { return getClassGenricType(clazz, 0); } /** * 通过反射, 获得Class定义中声明的父类的泛型参数的类型. * 如无法找到, 返回Object.class. * * 如public UserDao extends HibernateDao * * @param clazz clazz The class to introspect * @param index the Index of the generic ddeclaration,start from 0. * @return the index generic declaration, or Object.class if cannot be determined */ public static Class getClassGenricType(final Class clazz, final int index) { Type genType = clazz.getGenericSuperclass(); if (!(genType instanceof ParameterizedType)) { logger.warn(clazz.getSimpleName() + \"'s superclass not ParameterizedType\"); return Object.class; } Type[] params = ((ParameterizedType) genType).getActualTypeArguments(); if (index >= params.length || index getUserClass(Object instance) { Assert.notNull(instance, \"Instance must not be null\"); Class clazz = instance.getClass(); if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) { Class superClass = clazz.getSuperclass(); if (superClass != null && !Object.class.equals(superClass)) { return superClass; } } return clazz; } /** * 将反射时的checked exception转换为unchecked exception. */ public static RuntimeException convertReflectionExceptionToUnchecked(Exception e) { if (e instanceof IllegalAccessException || e instanceof IllegalArgumentException || e instanceof NoSuchMethodException) { return new IllegalArgumentException(e); } else if (e instanceof InvocationTargetException) { return new RuntimeException(((InvocationTargetException) e).getTargetException()); } else if (e instanceof RuntimeException) { return (RuntimeException) e; } return new RuntimeException(\"Unexpected Checked Exception.\", e); } /** * 判断某个对象是否拥有某个属性 * * @param obj 对象 * @param fieldName 属性名 * @return 有属性返回true * 无属性返回false */ public static boolean hasField(final Object obj, final String fieldName){ Field field = getAccessibleField(obj, fieldName); if (field == null) { return false; } return true; } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:31:13 "},"content/codePart/part2.html":{"url":"content/codePart/part2.html","title":"Cookie工具类","keywords":"","body":"CookieUtils工具类 package com.chinaitop.flagship.sxbl.utils; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.HashMap; import java.util.Map; /** * @author : sangskf * @package : com.chinaitop.flagship.sxbl.utils.CookiesUtil * @date : 2019/4/8 09:57 * @description : 该类可以从浏览器请求中提取出cookies并进行对cookis的相关操作 */ public class CookiesUtil { /** * 根据名字获取cookie * * @param request * @param name cookie名字 * @return */ public static Cookie getCookieByName(HttpServletRequest request, String name) { Map cookieMap = ReadCookieMap(request); if (cookieMap.containsKey(name)) { Cookie cookie = (Cookie) cookieMap.get(name); return cookie; } else { return null; } } /** * 将cookie封装到Map里面 * * @param request * @return */ private static Map ReadCookieMap(HttpServletRequest request) { Map cookieMap = new HashMap(); Cookie[] cookies = request.getCookies(); if (null != cookies) { for (Cookie cookie : cookies) { cookieMap.put(cookie.getName(), cookie); } } return cookieMap; } /** * 保存Cookies * * @param response servlet请求 * @param value 保存值 * @author jxf */ public static HttpServletResponse setCookie(HttpServletResponse response, String name, String value, int time) { return setCookie(response, name, value, time, \"/\"); } public static HttpServletResponse setCookie(HttpServletResponse response, String name, String value, int time, String path) { // new一个Cookie对象,键值对为参数 Cookie cookie = new Cookie(name, value); // tomcat下多应用共享 cookie.setPath(path); // 如果cookie的值中含有中文时，需要对cookie进行编码，不然会产生乱码 try { URLEncoder.encode(value, \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } cookie.setMaxAge(time); // 将Cookie添加到Response中,使之生效 response.addCookie(cookie); // addCookie后，如果已经存在相同名字的cookie，则最新的覆盖旧的cookie return response; } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:33:59 "},"content/codePart/part3.html":{"url":"content/codePart/part3.html","title":"Java图片高保真缩放","keywords":"","body":"Java图片高保真缩放 package com.xindai.auth.service.util; import java.awt.image.BufferedImage; import java.io.File; import java.io.FileOutputStream; import javax.imageio.ImageIO; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGEncodeParam; import com.sun.image.codec.jpeg.JPEGImageEncoder; public class NarrowImage { /** * @param im * 原始图像 * @param resizeTimes * 倍数,比如0.5就是缩小一半,0.98等等double类型 * @return 返回处理后的图像 */ public BufferedImage zoomImage(String src) { BufferedImage result = null; try { File srcfile = new File(src); if (!srcfile.exists()) { System.out.println(\"文件不存在\"); } BufferedImage im = ImageIO.read(srcfile); /* 原始图像的宽度和高度 */ int width = im.getWidth(); int height = im.getHeight(); // 压缩计算 float resizeTimes = 0.3f; /* 这个参数是要转化成的倍数,如果是1就是转化成1倍 */ /* 调整后的图片的宽度和高度 */ int toWidth = (int) (width * resizeTimes); int toHeight = (int) (height * resizeTimes); /* 新生成结果图片 */ result = new BufferedImage(toWidth, toHeight, BufferedImage.TYPE_INT_RGB); result.getGraphics().drawImage(im.getScaledInstance(toWidth, toHeight, java.awt.Image.SCALE_SMOOTH), 0, 0, null); } catch (Exception e) { System.out.println(\"创建缩略图发生异常\" + e.getMessage()); } return result; } public boolean writeHighQuality(BufferedImage im, String fileFullPath) { try { /* 输出到文件流 */ FileOutputStream newimage = new FileOutputStream(fileFullPath); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(newimage); JPEGEncodeParam jep = JPEGCodec.getDefaultJPEGEncodeParam(im); /* 压缩质量 */ jep.setQuality(0.9f, true); encoder.encode(im, jep); /* 近JPEG编码 */ newimage.close(); return true; } catch (Exception e) { return false; } finally { // 压缩完毕后，删除原文件 File file = new File(fileFullPath); // 如果文件路径所对应的文件存在，并且是一个文件，则直接删除 if (file.exists() && file.isFile()) { if (file.delete()) { System.out.println(\"删除文件\" + fileFullPath + \"成功！\"); } else { System.out.println(\"删除文件\" + fileFullPath + \"失败！\"); } } else { System.out.println(\"删除文件失败：\" + fileFullPath + \"不存在！\"); } } } /** * 测试图片压缩 * * @param args */ public static void main(String[] args) { String inputFoler = \"C:\\\\Users\\\\PC\\\\Desktop\\\\bcfb1f83-ee77-4e82-bf2f-48905b1089b1.jpg\"; /* 这儿填写你存放要缩小图片的文件夹全地址 */ String outputFolder = \"C:\\\\Users\\\\PC\\\\Desktop\\\\T-bcfb1f83-ee77-4e82-bf2f-48905b1089b1.jpg\"; /* 这儿填写你转化后的图片存放的文件夹 */ NarrowImage narrowImage = new NarrowImage(); narrowImage.writeHighQuality(narrowImage.zoomImage(inputFoler), outputFolder); } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:38:48 "}}