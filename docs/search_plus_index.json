{"./":{"url":"./","title":"Introduction","keywords":"","body":"程序员的日常工作记录 一个人的工作职位不怕低，只要你不放弃你的理想，拿目前的工作做一个踏脚石，一方面维持生活，一方面找时间充实自己，认准一个确定的方向去努力。慢慢的，你总会发现，你的努力没有白费。 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:41:20 "},"content/java/java1.html":{"url":"content/java/java1.html","title":"JVM原理讲解","keywords":"","body":"JVM原理讲解 本文从 JVM 结构入手，介绍了 Java 内存管理、对象创建、常量池等基础知识，对面试中 JVM 相关的基础题目进行了讲解。 基本问题 介绍下Java内存区域（运行时数据区） Java对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么） 对象的访问定位的两种方式（句柄和直接指针两种方式） 拓展问题 String类和常量池 8种基本类型的包装类和常量池 概述 对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要像C++程序员这样为每一个new操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题，正是因为Java程序员把内存控制权交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。 运行时数据区 Java虚拟机在执行Java程序的过程中会把它管理的内存分成若干个不同的数据区域。 线程私有的：程序计数器，虚拟机栈，本地方法栈 线程共享的：堆，方法区，直接内存 程序计数器 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器来选择去下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 从上面的介绍中我们知道程序计数器主要有两个作用: 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行，选择，循环，异常处理 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了 注意：程序计数器是唯一不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 Java虚拟机栈 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型。 Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有局部变量表，操作数栈，动态链接，方法出口信息） 局部变量表主要存放可编译器可知的各种数据类型(boolean, byte, char, short, int, float, long, double)，对象引用（refrence类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 Java虚拟机栈会出现两种异常: StackOverFlowError 和 OutOfMemoryError。 StackOverFlowEror：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 OutOfMemoryError: 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。 Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 本地方法栈 和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈会创建一个栈桢，用于存放该本地方法的局部变量表，操作数栈，动态链接，出口信息。 方法执行完毕后相应的栈桢也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种异常。 堆 Java虚拟机所管理的内存中最大的一块，Java堆使所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例以及数组都在这里分配内存。 Java堆是垃圾收集管理器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap)。从垃圾回收的角度，由于现在收集器基本采用的分代垃圾收集算法，所以Java堆还可以细分为: 新生代和老年代，再细致一点: Eden空间，From Survivor, To Survivor空间等。进一步划分的目的是更好的回收内存，或者更快的分配内存。 在JDK1.8中移除了整个永久代，取而代之的是一个叫元空间(Metaspace)的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。 【参考】Java8内存模型--永久代(PermGen)和元空间(Metaspace) 方法区 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java堆区分开来。 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:40:45 "},"content/java/java2.html":{"url":"content/java/java2.html","title":"java同步系列之JMM","keywords":"","body":"java同步系列之JMM（Java Memory Model） Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。 简介 Java内存模型是在硬件内存模型上的更高层的抽象，它屏蔽了各种硬件和操作系统访问的差异性，保证了Java程序在各种平台下对内存的访问都能达到一致的效果。 硬件内存模型 在正式讲解Java的内存模型之前，我们有必要先了解一下硬件层面的一些东西。 在现代计算机的硬件体系中，CPU的运算速度是非常快的，远远高于它从存储介质读取数据的速度，这里的存储介质有很多，比如磁盘、光盘、网卡、内存等，这些存储介质有一个很明显的特点——距离CPU越近的存储介质往往越小越贵越快，距离CPU越远的存储介质往往越大越便宜越慢。 所以，在程序运行的过程中，CPU大部分时间都浪费在了磁盘IO、网络通讯、数据库访问上，如果不想让CPU在那里白白等待，我们就必须想办法去把CPU的运算能力压榨出来，否则就会造成很大的浪费，而让CPU同时去处理多项任务则是最容易想到的，也是被证明非常有效的压榨手段，这也就是我们常说的“并发执行”。 但是，让CPU并发地执行多项任务并不是那么容易实现的事，因为所有的运算都不可能只依靠CPU的计算就能完成，往往还需要跟内存进行交互，如读取运算数据、存储运算结果等。 前面我们也说过了，CPU与内存的交互往往是很慢的，所以这就要求我们要想办法在CPU和内存之间建立一种连接，使它们达到一种平衡，让运算能快速地进行，而这种连接就是我们常说的“高速缓存”。 高速缓存的速度是非常接近CPU的，但是它的引入又带来了新的问题，现代的CPU往往是有多个核心的，每个核心都有自己的缓存，而多个核心之间是不存在时间片的竞争的，它们可以并行地执行，那么，怎么保证这些缓存与主内存中的数据的一致性就成为了一个难题。 为了解决缓存一致性的问题，多个核心在访问缓存时要遵循一些协议，在读写操作时根据协议来操作，这些协议有MSI、MESI、MOSI等，它们定义了何时应该访问缓存中的数据、何时应该让缓存失效、何时应该访问主内存中的数据等基本原则。 而随着CPU能力的不断提升，一层缓存就无法满足要求了，就逐渐衍生出了多级缓存。 按照数据读取顺序和CPU的紧密程度，CPU的缓存可以分为一级缓存（L1）、二级缓存（L2）、三级缓存（L3），每一级缓存存储的数据都是下一级的一部分。 这三种缓存的技术难度和制作成本是相对递减的，容量也是相对递增的。 所以，在有了多级缓存后，程序的运行就变成了： 当CPU要读取一个数据的时候，先从一级缓存中查找，如果没找到再从二级缓存中查找，如果没找到再从三级缓存中查找，如果没找到再从主内存中查找，然后再把找到的数据依次加载到多级缓存中，下次再使用相关的数据直接从缓存中查找即可。 而加载到缓存中的数据也不是说用到哪个就加载哪个，而是加载内存中连续的数据，一般来说是加载连续的64个字节，因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中，这就是“缓存行”的概念。 缓存行虽然能极大地提高程序运行的效率，但是在多线程对共享变量的访问过程中又带来了新的问题，也就是非常著名的“伪共享”。 关于伪共享的问题，我们这里就不展开讲了，有兴趣的可以看彤哥之前发布的【杂谈 什么是伪共享（false sharing）？】章节的相关内容。 除此之外，为了使CPU中的运算单元能够充分地被利用，CPU可能会对输入的代码进行乱序执行优化，然后在计算之后再将乱序执行的结果进行重组，保证该结果与顺序执行的结果一致，但并不保证程序中各个语句计算的先后顺序与代码的输入顺序一致，因此，如果一个计算任务依赖于另一个计算任务的结果，那么其顺序性并不能靠代码的先后顺序来保证。 与CPU的乱序执行优化类似，java虚拟机的即时编译器也有类似的指令重排序优化。 为了解决上面提到的多个缓存读写一致性以及乱序排序优化的问题，这就有了内存模型，它定义了共享内存系统中多线程读写操作行为的规范。 Java内存模型 Java内存模型（Java Memory Model，JMM）是在硬件内存模型基础上更高层的抽象，它屏蔽了各种硬件和操作系统对内存访问的差异性，从而实现让Java程序在各种平台下都能达到一致的并发效果。 Java内存模型定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里所说的变量包括实例字段、静态字段，但不包括局部变量和方法参数，因为它们是线程私有的，它们不会被共享，自然不存在竞争问题。 为了获得更好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码的执行顺序等这类权利。 Java内存模型规定了所有的变量都存储在主内存中，这里的主内存跟介绍硬件时所用的名字一样，两者可以类比，但此处仅指虚拟机中内存的一部分。 除了主内存，每条线程还有自己的工作内存，此处可与CPU的高速缓存进行类比。工作内存中保存着该线程使用到的变量的主内存副本的拷贝，线程对变量的操作都必须在工作内存中进行，包括读取和赋值等，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存来完成。 线程、工作内存、主内存三者的关系如下图所示： 注意，这里所说的主内存、工作内存跟Java虚拟机内存区域划分中的堆、栈是不同层次的内存划分，如果两者一定要勉强对应起来，主内存主要对应于堆中对象的实例部分，而工作内存主要对应与虚拟机栈中的部分区域。 从更低层次来说，主内存主要对应于硬件内存部分，工作内存主要对应于CPU的高速缓存和寄存器部分，但也不是绝对的，主内存也可能存在于高速缓存和寄存器中，工作内存也可能存在于硬件内存中。 内存间的交互操作 关于主内存与工作内存之间具体的交互协议，Java内存模型定义了以下8种具体的操作来完成： （1）lock，锁定，作用于主内存的变量，它把主内存中的变量标识为一条线程独占状态； （2）unlock，解锁，作用于主内存的变量，它把锁定的变量释放出来，释放出来的变量才可以被其它线程锁定； （3）read，读取，作用于主内存的变量，它把一个变量从主内存传输到工作内存中，以便后续的load操作使用； （4）load，载入，作用于工作内存的变量，它把read操作从主内存得到的变量放入工作内存的变量副本中； （5）use，使用，作用于工作内存的变量，它把工作内存中的一个变量传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作； （6）assign，赋值，作用于工作内存的变量，它把一个从执行引擎接收到的变量赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时使用这个操作； （7）store，存储，作用于工作内存的变量，它把工作内存中一个变量的值传递到主内存中，以便后续的write操作使用； （8）write，写入，作用于主内存的变量，它把store操作从工作内存得到的变量的值放入到主内存的变量中； 如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，同样地，如果要把一个变量从工作内存同步回主内存，就要按顺序地执行store和write操作。注意，这里只说明了要按顺序，并没有说一定要连续，也就是说可以在read与load之间、store与write之间插入其它操作。比如，对主内存中的变量a和b的访问，可以按照以下顺序执行： read a -> read b -> load b -> load a。 另外，Java内存模型还定义了执行上述8种操作的基本规则： （1）不允许read和load、store和write操作之一单独出现，即不允许出现从主内存读取了而工作内存不接受，或者从工作内存回写了但主内存不接受的情况出现； （2）不允许一个线程丢弃它最近的assign操作，即变量在工作内存变化了必须把该变化同步回主内存； （3）不允许一个线程无原因地（即未发生过assign操作）把一个变量从工作内存同步回主内存； （4）一个新的变量必须在主内存中诞生，不允许工作内存中直接使用一个未被初始化（load或assign）过的变量，换句话说就是对一个变量的use和store操作之前必须执行过load和assign操作； （5）一个变量同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能被解锁。 （6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值； （7）如果一个变量没有被lock操作锁定，则不允许对其执行unlock操作，也不允许unlock一个其它线程锁定的变量； （8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作； 注意，这里的lock和unlock是实现synchronized的基础，Java并没有把lock和unlock操作直接开放给用户使用，但是却提供了两个更高层次的指令来隐式地使用这两个操作，即moniterenter和moniterexit。 原子性、可见性、有序性 Java内存模型就是为了解决多线程环境下共享变量的一致性问题，那么一致性包含哪些内容呢？ 一致性主要包含三大特性：原子性、可见性、有序性，下面我们就来看看Java内存模型是怎么实现这三大特性的。 （1）原子性 原子性是指一段操作一旦开始就会一直运行到底，中间不会被其它线程打断，这段操作可以是一个操作，也可以是多个操作。 由Java内存模型来直接保证的原子性操作包括read、load、user、assign、store、write这两个操作，我们可以大致认为基本类型变量的读写是具备原子性的。 如果应用需要一个更大范围的原子性，Java内存模型还提供了lock和unlock这两个操作来满足这种需求，尽管不能直接使用这两个操作，但我们可以使用它们更具体的实现synchronized来实现。 因此，synchronized块之间的操作也是原子性的。 （2）可见性 可见性是指当一个线程修改了共享变量的值，其它线程能立即感知到这种变化。 Java内存模型是通过在变更修改后同步回主内存，在变量读取前从主内存刷新变量值来实现的，它是依赖主内存的，无论是普通变量还是volatile变量都是如此。 普通变量与volatile变量的主要区别是是否会在修改之后立即同步回主内存，以及是否在每次读取前立即从主内存刷新。因此我们可以说volatile变量保证了多线程环境下变量的可见性，但普通变量不能保证这一点。 除了volatile之外，还有两个关键字也可以保证可见性，它们是synchronized和final。 synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作”这条规则获取的。 final的可见性是指被final修饰的字段在构造器中一旦被初始化完成，那么其它线程中就能看见这个final字段了。 （3）有序性 Java程序中天然的有序性可以总结为一句话：如果在本线程中观察，所有的操作都是有序的；如果在另一个线程中观察，所有的操作都是无序的。 前半句是指线程内表现为串行的语义，后半句是指“指令重排序”现象和“工作内存和主内存同步延迟”现象。 Java中提供了volatile和synchronized两个关键字来保证有序性。 volatile天然就具有有序性，因为其禁止重排序。 synchronized的有序性是由“一个变量同一时刻只允许一条线程对其进行lock操作”这条规则获取的。 先行发生原则（Happens-Before） 如果Java内存模型的有序性都只依靠volatile和synchronized来完成，那么有一些操作就会变得很啰嗦，但是我们在编写Java并发代码时并没有感受到，这是因为Java语言天然定义了一个“先行发生”原则，这个原则非常重要，依靠这个原则我们可以很容易地判断在并发环境下两个操作是否可能存在竞争冲突问题。 先行发生，是指操作A先行发生于操作B，那么操作A产生的影响能够被操作B感知到，这种影响包括修改了共享内存中变量的值、发送了消息、调用了方法等。 下面我们看看Java内存模型定义的先行发生原则有哪些： （1）程序次序原则 在一个线程内，按照程序书写的顺序执行，书写在前面的操作先行发生于书写在后面的操作，准确地讲是控制流顺序而不是代码顺序，因为要考虑分支、循环等情况。 （2）监视器锁定原则 一个unlock操作先行发生于后面对同一个锁的lock操作。 （3）volatile原则 对一个volatile变量的写操作先行发生于后面对该变量的读操作。 （4）线程启动原则 对线程的start()操作先行发生于线程内的任何操作。 （5）线程终止原则 线程中的所有操作先行发生于检测到线程终止，可以通过Thread.join()、Thread.isAlive()的返回值检测线程是否已经终止。 （6）线程中断原则 对线程的interrupt()的调用先行发生于线程的代码中检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否发生中断。 （7）对象终结原则 一个对象的初始化完成（构造方法执行结束）先行发生于它的finalize()方法的开始。 （8）传递性原则 如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。 这里说的“先行发生”与“时间上的先发生”没有必然的关系。 比如，下面的代码： int a = 0; // 操作A：线程1对进行赋值操作 a = 1; // 操作B：线程2获取a的值 int b = a; 复制代码 如果线程1在时间顺序上先对a进行赋值，然后线程2再获取a的值，这能说明操作A先行发生于操作B吗？ 显然不能，因为线程2可能读取的还是其工作内存中的值，或者说线程1并没有把a的值刷新回主内存呢，这时候线程2读取到的值可能还是0。 所以，“时间上的先发生”不一定“先行发生”。 再看一个例子： // 同一个线程中 int i = 1; int j = 2; 复制代码 根据第一条程序次序原则，int i = 1;先行发生于int j = 2;，但是由于处理器优化，可能导致int j = 2;先执行，但是这并不影响先行发生原则的正确性，因为我们在这个线程中并不会感知到这点。 所以，“先行发生”不一定“时间上先发生”。 总结 （1）硬件内存架构使得我们必须建立内存模型来保证多线程环境下对共享内存访问的正确性； （2）Java内存模型定义了保证多线程环境下共享变量一致性的规则； （3）Java内存模型提供了工作内存与主内存交互的8大操作：lock、unlock、read、load、use、assign、store、write； （4）Java内存模型对原子性、可见性、有序性提供了一些实现； （5）先行发生的8大原则：程序次序原则、监视器锁定原则、volatile原则、线程启动原则、线程终止原则、线程中断原则、对象终结原则、传递性原则； （6）先行发生不等于时间上的先发生； Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 21:09:34 "},"content/codePart/part1.html":{"url":"content/codePart/part1.html","title":"反射工具类","keywords":"","body":"反射工具类 package com.github.wxiaoqi.security.common.util; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import org.apache.commons.lang3.StringUtils; import org.apache.commons.lang3.Validate; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.Assert; /** * 反射工具类. * 提供调用getter/setter方法, 访问私有变量, 调用私有方法, 获取泛型类型Class, 被AOP过的真实类等工具函数. * @author calvin * @version 2013-01-15 */ @SuppressWarnings(\"rawtypes\") public class ReflectionUtils { private static final String SETTER_PREFIX = \"set\"; private static final String GETTER_PREFIX = \"get\"; private static final String CGLIB_CLASS_SEPARATOR = \"$$\"; private static Logger logger = LoggerFactory.getLogger(ReflectionUtils.class); /** * 调用Getter方法. * 支持多级，如：对象名.对象名.方法 */ public static Object invokeGetter(Object obj, String propertyName) { Object object = obj; for (String name : StringUtils.split(propertyName, \".\")){ String getterMethodName = GETTER_PREFIX + StringUtils.capitalize(name); object = invokeMethod(object, getterMethodName, new Class[] {}, new Object[] {}); } return object; } /** * 调用Setter方法, 仅匹配方法名。 * 支持多级，如：对象名.对象名.方法 */ public static void invokeSetter(Object obj, String propertyName, Object value) { Object object = obj; String[] names = StringUtils.split(propertyName, \".\"); for (int i=0; i type) { if (object instanceof Number) { Number number = (Number) object; if (type.equals(byte.class) || type.equals(Byte.class)) { return number.byteValue(); } if (type.equals(short.class) || type.equals(Short.class)) { return number.shortValue(); } if (type.equals(int.class) || type.equals(Integer.class)) { return number.intValue(); } if (type.equals(long.class) || type.equals(Long.class)) { return number.longValue(); } if (type.equals(float.class) || type.equals(Float.class)) { return number.floatValue(); } if (type.equals(double.class) || type.equals(Double.class)) { return number.doubleValue(); } } if(type.equals(String.class)){ return object==null?\"\":object.toString(); } return object; } /** * 直接调用对象方法, 无视private/protected修饰符. * 用于一次性调用的情况，否则应使用getAccessibleMethod()函数获得Method后反复调用. * 同时匹配方法名+参数类型， */ public static Object invokeMethod(final Object obj, final String methodName, final Class[] parameterTypes, final Object[] args) { Method method = getAccessibleMethod(obj, methodName, parameterTypes); if (method == null) { throw new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + obj + \"]\"); } try { return method.invoke(obj, args); } catch (Exception e) { throw convertReflectionExceptionToUnchecked(e); } } /** * 直接调用对象方法, 无视private/protected修饰符， * 用于一次性调用的情况，否则应使用getAccessibleMethodByName()函数获得Method后反复调用. * 只匹配函数名，如果有多个同名函数调用第一个。 */ public static Object invokeMethodByName(final Object obj, final String methodName, final Object[] args) { Method method = getAccessibleMethodByName(obj, methodName); if (method == null) { throw new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + obj + \"]\"); } try { return method.invoke(obj, args); } catch (Exception e) { throw convertReflectionExceptionToUnchecked(e); } } /** * 循环向上转型, 获取对象的DeclaredField, 并强制设置为可访问. * * 如向上转型到Object仍无法找到, 返回null. */ public static Field getAccessibleField(final Object obj, final String fieldName) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(fieldName, \"fieldName can't be blank\"); for (Class superClass = obj.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()) { try { Field field = superClass.getDeclaredField(fieldName); makeAccessible(field); return field; } catch (NoSuchFieldException e) {//NOSONAR // Field不在当前类定义,继续向上转型 continue;// new add } } return null; } /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 匹配函数名+参数类型。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) */ public static Method getAccessibleMethod(final Object obj, final String methodName, final Class... parameterTypes) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(methodName, \"methodName can't be blank\"); for (Class searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) { try { Method method = searchType.getDeclaredMethod(methodName, parameterTypes); makeAccessible(method); return method; } catch (NoSuchMethodException e) { // Method不在当前类定义,继续向上转型 continue;// new add } } return null; } /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 只匹配函数名。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) */ public static Method getAccessibleMethodByName(final Object obj, final String methodName) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(methodName, \"methodName can't be blank\"); for (Class searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) { Method[] methods = searchType.getDeclaredMethods(); for (Method method : methods) { if (method.getName().equals(methodName)) { makeAccessible(method); return method; } } } return null; } /** * 改变private/protected的方法为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 */ public static void makeAccessible(Method method) { if ((!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) { method.setAccessible(true); } } /** * 改变private/protected的成员变量为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 */ public static void makeAccessible(Field field) { if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier .isFinal(field.getModifiers())) && !field.isAccessible()) { field.setAccessible(true); } } /** * 通过反射, 获得Class定义中声明的泛型参数的类型, 注意泛型必须定义在父类处 * 如无法找到, 返回Object.class. * eg. * public UserDao extends HibernateDao * * @param clazz The class to introspect * @return the first generic declaration, or Object.class if cannot be determined */ @SuppressWarnings(\"unchecked\") public static Class getClassGenricType(final Class clazz) { return getClassGenricType(clazz, 0); } /** * 通过反射, 获得Class定义中声明的父类的泛型参数的类型. * 如无法找到, 返回Object.class. * * 如public UserDao extends HibernateDao * * @param clazz clazz The class to introspect * @param index the Index of the generic ddeclaration,start from 0. * @return the index generic declaration, or Object.class if cannot be determined */ public static Class getClassGenricType(final Class clazz, final int index) { Type genType = clazz.getGenericSuperclass(); if (!(genType instanceof ParameterizedType)) { logger.warn(clazz.getSimpleName() + \"'s superclass not ParameterizedType\"); return Object.class; } Type[] params = ((ParameterizedType) genType).getActualTypeArguments(); if (index >= params.length || index getUserClass(Object instance) { Assert.notNull(instance, \"Instance must not be null\"); Class clazz = instance.getClass(); if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) { Class superClass = clazz.getSuperclass(); if (superClass != null && !Object.class.equals(superClass)) { return superClass; } } return clazz; } /** * 将反射时的checked exception转换为unchecked exception. */ public static RuntimeException convertReflectionExceptionToUnchecked(Exception e) { if (e instanceof IllegalAccessException || e instanceof IllegalArgumentException || e instanceof NoSuchMethodException) { return new IllegalArgumentException(e); } else if (e instanceof InvocationTargetException) { return new RuntimeException(((InvocationTargetException) e).getTargetException()); } else if (e instanceof RuntimeException) { return (RuntimeException) e; } return new RuntimeException(\"Unexpected Checked Exception.\", e); } /** * 判断某个对象是否拥有某个属性 * * @param obj 对象 * @param fieldName 属性名 * @return 有属性返回true * 无属性返回false */ public static boolean hasField(final Object obj, final String fieldName){ Field field = getAccessibleField(obj, fieldName); if (field == null) { return false; } return true; } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:31:13 "},"content/codePart/part2.html":{"url":"content/codePart/part2.html","title":"Cookie工具类","keywords":"","body":"CookieUtils工具类 package com.chinaitop.flagship.sxbl.utils; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.HashMap; import java.util.Map; /** * @author : sangskf * @package : com.chinaitop.flagship.sxbl.utils.CookiesUtil * @date : 2019/4/8 09:57 * @description : 该类可以从浏览器请求中提取出cookies并进行对cookis的相关操作 */ public class CookiesUtil { /** * 根据名字获取cookie * * @param request * @param name cookie名字 * @return */ public static Cookie getCookieByName(HttpServletRequest request, String name) { Map cookieMap = ReadCookieMap(request); if (cookieMap.containsKey(name)) { Cookie cookie = (Cookie) cookieMap.get(name); return cookie; } else { return null; } } /** * 将cookie封装到Map里面 * * @param request * @return */ private static Map ReadCookieMap(HttpServletRequest request) { Map cookieMap = new HashMap(); Cookie[] cookies = request.getCookies(); if (null != cookies) { for (Cookie cookie : cookies) { cookieMap.put(cookie.getName(), cookie); } } return cookieMap; } /** * 保存Cookies * * @param response servlet请求 * @param value 保存值 * @author jxf */ public static HttpServletResponse setCookie(HttpServletResponse response, String name, String value, int time) { return setCookie(response, name, value, time, \"/\"); } public static HttpServletResponse setCookie(HttpServletResponse response, String name, String value, int time, String path) { // new一个Cookie对象,键值对为参数 Cookie cookie = new Cookie(name, value); // tomcat下多应用共享 cookie.setPath(path); // 如果cookie的值中含有中文时，需要对cookie进行编码，不然会产生乱码 try { URLEncoder.encode(value, \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } cookie.setMaxAge(time); // 将Cookie添加到Response中,使之生效 response.addCookie(cookie); // addCookie后，如果已经存在相同名字的cookie，则最新的覆盖旧的cookie return response; } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:33:59 "},"content/codePart/part3.html":{"url":"content/codePart/part3.html","title":"Java图片高保真缩放","keywords":"","body":"Java图片高保真缩放 package com.xindai.auth.service.util; import java.awt.image.BufferedImage; import java.io.File; import java.io.FileOutputStream; import javax.imageio.ImageIO; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGEncodeParam; import com.sun.image.codec.jpeg.JPEGImageEncoder; public class NarrowImage { /** * @param im * 原始图像 * @param resizeTimes * 倍数,比如0.5就是缩小一半,0.98等等double类型 * @return 返回处理后的图像 */ public BufferedImage zoomImage(String src) { BufferedImage result = null; try { File srcfile = new File(src); if (!srcfile.exists()) { System.out.println(\"文件不存在\"); } BufferedImage im = ImageIO.read(srcfile); /* 原始图像的宽度和高度 */ int width = im.getWidth(); int height = im.getHeight(); // 压缩计算 float resizeTimes = 0.3f; /* 这个参数是要转化成的倍数,如果是1就是转化成1倍 */ /* 调整后的图片的宽度和高度 */ int toWidth = (int) (width * resizeTimes); int toHeight = (int) (height * resizeTimes); /* 新生成结果图片 */ result = new BufferedImage(toWidth, toHeight, BufferedImage.TYPE_INT_RGB); result.getGraphics().drawImage(im.getScaledInstance(toWidth, toHeight, java.awt.Image.SCALE_SMOOTH), 0, 0, null); } catch (Exception e) { System.out.println(\"创建缩略图发生异常\" + e.getMessage()); } return result; } public boolean writeHighQuality(BufferedImage im, String fileFullPath) { try { /* 输出到文件流 */ FileOutputStream newimage = new FileOutputStream(fileFullPath); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(newimage); JPEGEncodeParam jep = JPEGCodec.getDefaultJPEGEncodeParam(im); /* 压缩质量 */ jep.setQuality(0.9f, true); encoder.encode(im, jep); /* 近JPEG编码 */ newimage.close(); return true; } catch (Exception e) { return false; } finally { // 压缩完毕后，删除原文件 File file = new File(fileFullPath); // 如果文件路径所对应的文件存在，并且是一个文件，则直接删除 if (file.exists() && file.isFile()) { if (file.delete()) { System.out.println(\"删除文件\" + fileFullPath + \"成功！\"); } else { System.out.println(\"删除文件\" + fileFullPath + \"失败！\"); } } else { System.out.println(\"删除文件失败：\" + fileFullPath + \"不存在！\"); } } } /** * 测试图片压缩 * * @param args */ public static void main(String[] args) { String inputFoler = \"C:\\\\Users\\\\PC\\\\Desktop\\\\bcfb1f83-ee77-4e82-bf2f-48905b1089b1.jpg\"; /* 这儿填写你存放要缩小图片的文件夹全地址 */ String outputFolder = \"C:\\\\Users\\\\PC\\\\Desktop\\\\T-bcfb1f83-ee77-4e82-bf2f-48905b1089b1.jpg\"; /* 这儿填写你转化后的图片存放的文件夹 */ NarrowImage narrowImage = new NarrowImage(); narrowImage.writeHighQuality(narrowImage.zoomImage(inputFoler), outputFolder); } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:38:48 "}}