{"./":{"url":"./","title":"Introduction","keywords":"","body":"程序员的日常工作记录 一个人的工作职位不怕低，只要你不放弃你的理想，拿目前的工作做一个踏脚石，一方面维持生活，一方面找时间充实自己，认准一个确定的方向去努力。慢慢的，你总会发现，你的努力没有白费。 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:41:20 "},"content/java/java1.html":{"url":"content/java/java1.html","title":"JVM原理讲解","keywords":"","body":"JVM原理讲解 本文从 JVM 结构入手，介绍了 Java 内存管理、对象创建、常量池等基础知识，对面试中 JVM 相关的基础题目进行了讲解。 基本问题 介绍下Java内存区域（运行时数据区） Java对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么） 对象的访问定位的两种方式（句柄和直接指针两种方式） 拓展问题 String类和常量池 8种基本类型的包装类和常量池 概述 对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要像C++程序员这样为每一个new操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题，正是因为Java程序员把内存控制权交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。 运行时数据区 Java虚拟机在执行Java程序的过程中会把它管理的内存分成若干个不同的数据区域。 线程私有的：程序计数器，虚拟机栈，本地方法栈 线程共享的：堆，方法区，直接内存 程序计数器 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器来选择去下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 从上面的介绍中我们知道程序计数器主要有两个作用: 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行，选择，循环，异常处理 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了 注意：程序计数器是唯一不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 Java虚拟机栈 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型。 Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有局部变量表，操作数栈，动态链接，方法出口信息） 局部变量表主要存放可编译器可知的各种数据类型(boolean, byte, char, short, int, float, long, double)，对象引用（refrence类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 Java虚拟机栈会出现两种异常: StackOverFlowError 和 OutOfMemoryError。 StackOverFlowEror：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 OutOfMemoryError: 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。 Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 本地方法栈 和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈会创建一个栈桢，用于存放该本地方法的局部变量表，操作数栈，动态链接，出口信息。 方法执行完毕后相应的栈桢也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种异常。 堆 Java虚拟机所管理的内存中最大的一块，Java堆使所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例以及数组都在这里分配内存。 Java堆是垃圾收集管理器管理的主要区域，因此也被称为GC堆(Garbage Collected Heap)。从垃圾回收的角度，由于现在收集器基本采用的分代垃圾收集算法，所以Java堆还可以细分为: 新生代和老年代，再细致一点: Eden空间，From Survivor, To Survivor空间等。进一步划分的目的是更好的回收内存，或者更快的分配内存。 在JDK1.8中移除了整个永久代，取而代之的是一个叫元空间(Metaspace)的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。 【参考】Java8内存模型--永久代(PermGen)和元空间(Metaspace) 方法区 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java堆区分开来。 Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:40:45 "},"content/codePart/part1.html":{"url":"content/codePart/part1.html","title":"反射工具类","keywords":"","body":"反射工具类 package com.github.wxiaoqi.security.common.util; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import org.apache.commons.lang3.StringUtils; import org.apache.commons.lang3.Validate; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.Assert; /** * 反射工具类. * 提供调用getter/setter方法, 访问私有变量, 调用私有方法, 获取泛型类型Class, 被AOP过的真实类等工具函数. * @author calvin * @version 2013-01-15 */ @SuppressWarnings(\"rawtypes\") public class ReflectionUtils { private static final String SETTER_PREFIX = \"set\"; private static final String GETTER_PREFIX = \"get\"; private static final String CGLIB_CLASS_SEPARATOR = \"$$\"; private static Logger logger = LoggerFactory.getLogger(ReflectionUtils.class); /** * 调用Getter方法. * 支持多级，如：对象名.对象名.方法 */ public static Object invokeGetter(Object obj, String propertyName) { Object object = obj; for (String name : StringUtils.split(propertyName, \".\")){ String getterMethodName = GETTER_PREFIX + StringUtils.capitalize(name); object = invokeMethod(object, getterMethodName, new Class[] {}, new Object[] {}); } return object; } /** * 调用Setter方法, 仅匹配方法名。 * 支持多级，如：对象名.对象名.方法 */ public static void invokeSetter(Object obj, String propertyName, Object value) { Object object = obj; String[] names = StringUtils.split(propertyName, \".\"); for (int i=0; i type) { if (object instanceof Number) { Number number = (Number) object; if (type.equals(byte.class) || type.equals(Byte.class)) { return number.byteValue(); } if (type.equals(short.class) || type.equals(Short.class)) { return number.shortValue(); } if (type.equals(int.class) || type.equals(Integer.class)) { return number.intValue(); } if (type.equals(long.class) || type.equals(Long.class)) { return number.longValue(); } if (type.equals(float.class) || type.equals(Float.class)) { return number.floatValue(); } if (type.equals(double.class) || type.equals(Double.class)) { return number.doubleValue(); } } if(type.equals(String.class)){ return object==null?\"\":object.toString(); } return object; } /** * 直接调用对象方法, 无视private/protected修饰符. * 用于一次性调用的情况，否则应使用getAccessibleMethod()函数获得Method后反复调用. * 同时匹配方法名+参数类型， */ public static Object invokeMethod(final Object obj, final String methodName, final Class[] parameterTypes, final Object[] args) { Method method = getAccessibleMethod(obj, methodName, parameterTypes); if (method == null) { throw new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + obj + \"]\"); } try { return method.invoke(obj, args); } catch (Exception e) { throw convertReflectionExceptionToUnchecked(e); } } /** * 直接调用对象方法, 无视private/protected修饰符， * 用于一次性调用的情况，否则应使用getAccessibleMethodByName()函数获得Method后反复调用. * 只匹配函数名，如果有多个同名函数调用第一个。 */ public static Object invokeMethodByName(final Object obj, final String methodName, final Object[] args) { Method method = getAccessibleMethodByName(obj, methodName); if (method == null) { throw new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + obj + \"]\"); } try { return method.invoke(obj, args); } catch (Exception e) { throw convertReflectionExceptionToUnchecked(e); } } /** * 循环向上转型, 获取对象的DeclaredField, 并强制设置为可访问. * * 如向上转型到Object仍无法找到, 返回null. */ public static Field getAccessibleField(final Object obj, final String fieldName) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(fieldName, \"fieldName can't be blank\"); for (Class superClass = obj.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()) { try { Field field = superClass.getDeclaredField(fieldName); makeAccessible(field); return field; } catch (NoSuchFieldException e) {//NOSONAR // Field不在当前类定义,继续向上转型 continue;// new add } } return null; } /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 匹配函数名+参数类型。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) */ public static Method getAccessibleMethod(final Object obj, final String methodName, final Class... parameterTypes) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(methodName, \"methodName can't be blank\"); for (Class searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) { try { Method method = searchType.getDeclaredMethod(methodName, parameterTypes); makeAccessible(method); return method; } catch (NoSuchMethodException e) { // Method不在当前类定义,继续向上转型 continue;// new add } } return null; } /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 只匹配函数名。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) */ public static Method getAccessibleMethodByName(final Object obj, final String methodName) { Validate.notNull(obj, \"object can't be null\"); Validate.notBlank(methodName, \"methodName can't be blank\"); for (Class searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) { Method[] methods = searchType.getDeclaredMethods(); for (Method method : methods) { if (method.getName().equals(methodName)) { makeAccessible(method); return method; } } } return null; } /** * 改变private/protected的方法为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 */ public static void makeAccessible(Method method) { if ((!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) { method.setAccessible(true); } } /** * 改变private/protected的成员变量为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 */ public static void makeAccessible(Field field) { if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier .isFinal(field.getModifiers())) && !field.isAccessible()) { field.setAccessible(true); } } /** * 通过反射, 获得Class定义中声明的泛型参数的类型, 注意泛型必须定义在父类处 * 如无法找到, 返回Object.class. * eg. * public UserDao extends HibernateDao * * @param clazz The class to introspect * @return the first generic declaration, or Object.class if cannot be determined */ @SuppressWarnings(\"unchecked\") public static Class getClassGenricType(final Class clazz) { return getClassGenricType(clazz, 0); } /** * 通过反射, 获得Class定义中声明的父类的泛型参数的类型. * 如无法找到, 返回Object.class. * * 如public UserDao extends HibernateDao * * @param clazz clazz The class to introspect * @param index the Index of the generic ddeclaration,start from 0. * @return the index generic declaration, or Object.class if cannot be determined */ public static Class getClassGenricType(final Class clazz, final int index) { Type genType = clazz.getGenericSuperclass(); if (!(genType instanceof ParameterizedType)) { logger.warn(clazz.getSimpleName() + \"'s superclass not ParameterizedType\"); return Object.class; } Type[] params = ((ParameterizedType) genType).getActualTypeArguments(); if (index >= params.length || index getUserClass(Object instance) { Assert.notNull(instance, \"Instance must not be null\"); Class clazz = instance.getClass(); if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) { Class superClass = clazz.getSuperclass(); if (superClass != null && !Object.class.equals(superClass)) { return superClass; } } return clazz; } /** * 将反射时的checked exception转换为unchecked exception. */ public static RuntimeException convertReflectionExceptionToUnchecked(Exception e) { if (e instanceof IllegalAccessException || e instanceof IllegalArgumentException || e instanceof NoSuchMethodException) { return new IllegalArgumentException(e); } else if (e instanceof InvocationTargetException) { return new RuntimeException(((InvocationTargetException) e).getTargetException()); } else if (e instanceof RuntimeException) { return (RuntimeException) e; } return new RuntimeException(\"Unexpected Checked Exception.\", e); } /** * 判断某个对象是否拥有某个属性 * * @param obj 对象 * @param fieldName 属性名 * @return 有属性返回true * 无属性返回false */ public static boolean hasField(final Object obj, final String fieldName){ Field field = getAccessibleField(obj, fieldName); if (field == null) { return false; } return true; } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:31:13 "},"content/codePart/part2.html":{"url":"content/codePart/part2.html","title":"Cookie工具类","keywords":"","body":"CookieUtils工具类 package com.chinaitop.flagship.sxbl.utils; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.HashMap; import java.util.Map; /** * @author : sangskf * @package : com.chinaitop.flagship.sxbl.utils.CookiesUtil * @date : 2019/4/8 09:57 * @description : 该类可以从浏览器请求中提取出cookies并进行对cookis的相关操作 */ public class CookiesUtil { /** * 根据名字获取cookie * * @param request * @param name cookie名字 * @return */ public static Cookie getCookieByName(HttpServletRequest request, String name) { Map cookieMap = ReadCookieMap(request); if (cookieMap.containsKey(name)) { Cookie cookie = (Cookie) cookieMap.get(name); return cookie; } else { return null; } } /** * 将cookie封装到Map里面 * * @param request * @return */ private static Map ReadCookieMap(HttpServletRequest request) { Map cookieMap = new HashMap(); Cookie[] cookies = request.getCookies(); if (null != cookies) { for (Cookie cookie : cookies) { cookieMap.put(cookie.getName(), cookie); } } return cookieMap; } /** * 保存Cookies * * @param response servlet请求 * @param value 保存值 * @author jxf */ public static HttpServletResponse setCookie(HttpServletResponse response, String name, String value, int time) { return setCookie(response, name, value, time, \"/\"); } public static HttpServletResponse setCookie(HttpServletResponse response, String name, String value, int time, String path) { // new一个Cookie对象,键值对为参数 Cookie cookie = new Cookie(name, value); // tomcat下多应用共享 cookie.setPath(path); // 如果cookie的值中含有中文时，需要对cookie进行编码，不然会产生乱码 try { URLEncoder.encode(value, \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } cookie.setMaxAge(time); // 将Cookie添加到Response中,使之生效 response.addCookie(cookie); // addCookie后，如果已经存在相同名字的cookie，则最新的覆盖旧的cookie return response; } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:33:59 "},"content/codePart/part3.html":{"url":"content/codePart/part3.html","title":"Java图片高保真缩放","keywords":"","body":"Java图片高保真缩放 package com.xindai.auth.service.util; import java.awt.image.BufferedImage; import java.io.File; import java.io.FileOutputStream; import javax.imageio.ImageIO; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGEncodeParam; import com.sun.image.codec.jpeg.JPEGImageEncoder; public class NarrowImage { /** * @param im * 原始图像 * @param resizeTimes * 倍数,比如0.5就是缩小一半,0.98等等double类型 * @return 返回处理后的图像 */ public BufferedImage zoomImage(String src) { BufferedImage result = null; try { File srcfile = new File(src); if (!srcfile.exists()) { System.out.println(\"文件不存在\"); } BufferedImage im = ImageIO.read(srcfile); /* 原始图像的宽度和高度 */ int width = im.getWidth(); int height = im.getHeight(); // 压缩计算 float resizeTimes = 0.3f; /* 这个参数是要转化成的倍数,如果是1就是转化成1倍 */ /* 调整后的图片的宽度和高度 */ int toWidth = (int) (width * resizeTimes); int toHeight = (int) (height * resizeTimes); /* 新生成结果图片 */ result = new BufferedImage(toWidth, toHeight, BufferedImage.TYPE_INT_RGB); result.getGraphics().drawImage(im.getScaledInstance(toWidth, toHeight, java.awt.Image.SCALE_SMOOTH), 0, 0, null); } catch (Exception e) { System.out.println(\"创建缩略图发生异常\" + e.getMessage()); } return result; } public boolean writeHighQuality(BufferedImage im, String fileFullPath) { try { /* 输出到文件流 */ FileOutputStream newimage = new FileOutputStream(fileFullPath); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(newimage); JPEGEncodeParam jep = JPEGCodec.getDefaultJPEGEncodeParam(im); /* 压缩质量 */ jep.setQuality(0.9f, true); encoder.encode(im, jep); /* 近JPEG编码 */ newimage.close(); return true; } catch (Exception e) { return false; } finally { // 压缩完毕后，删除原文件 File file = new File(fileFullPath); // 如果文件路径所对应的文件存在，并且是一个文件，则直接删除 if (file.exists() && file.isFile()) { if (file.delete()) { System.out.println(\"删除文件\" + fileFullPath + \"成功！\"); } else { System.out.println(\"删除文件\" + fileFullPath + \"失败！\"); } } else { System.out.println(\"删除文件失败：\" + fileFullPath + \"不存在！\"); } } } /** * 测试图片压缩 * * @param args */ public static void main(String[] args) { String inputFoler = \"C:\\\\Users\\\\PC\\\\Desktop\\\\bcfb1f83-ee77-4e82-bf2f-48905b1089b1.jpg\"; /* 这儿填写你存放要缩小图片的文件夹全地址 */ String outputFolder = \"C:\\\\Users\\\\PC\\\\Desktop\\\\T-bcfb1f83-ee77-4e82-bf2f-48905b1089b1.jpg\"; /* 这儿填写你转化后的图片存放的文件夹 */ NarrowImage narrowImage = new NarrowImage(); narrowImage.writeHighQuality(narrowImage.zoomImage(inputFoler), outputFolder); } } Copyright © books.sangkf.cn 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 17:38:48 "}}